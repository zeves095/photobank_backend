<?php
/**
  * Сервис для работы с генерацией изображений
  */
namespace App\Service;

use Doctrine\ORM\EntityManagerInterface;
use App\Entity\Resource;
use App\Service\ResourceService;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\DependencyInjection\ContainerInterface;
use \Imagine\Imagick\Imagine;
use \Imagine\Image\Box;
use \Imagine\Image\ImageInterface;


/**
  * Сервис для работы с генерацией изображений
  */
class ImageProcessorService{

  /**
  * Инструмент работы с сущностями Doctrine ORM
  */
private $entityManager;
  /**
  * Сервис-контейнер Symfony
  */
private $container;
/**
 * Сервис для работы с сущностями типа Resource
 */
  private $resourceService;
  /**
  * Сервис работы с файловой системой Symfony
  */
private $fileSystem;

  /**
   * Конструктор класса
   * @param EntityManagerInterface $entityManager   Инструмент для работы с сущностями Doctrine ORM
   * @param ContainerInterface     $container       Сервис-контейнер Symfony
   * @param ResourceService        $resourceService Сервис для работы с сущностями типа Resource
   * @param Filesystem             $fileSystem      Сервис работы с файловой системой Symfony
   */
  public function __construct(EntityManagerInterface $entityManager, ContainerInterface $container, ResourceService $resourceService, Filesystem $fileSystem)
  {
    $this->entityManager = $entityManager;
    $this->container = $container;
    $this->resourceService = $resourceService;
    $this->fileSystem = $fileSystem;
  }

  /**
    * Запускает процесс генерации пресета для конкретного ресурса
    *
    * @param int $resourceId Идентификатор ресурса для обработки
    * @param int $presetId Идентификатор пресета
    *
    */
  public function processPreset($resourceId, $presetId)
  {

    $repository = $this->entityManager->getRepository(Resource::class);
    $processed = $repository->findBy(['gid'=>$resourceId]);
    $resource = $repository->findOneBy(['id'=>$resourceId]);

    $processedPresets = array();
    foreach($processed as $p){
      array_push($processedPresets, $p->getPreset());
    }
    if(!in_array($presetId, $processedPresets)){
      $this->_savePreset($resource,$presetId);
    }

    return true;
  }

  /**
    * Определяет параметры генерации изображения не по пресету, а с отдельно заданными шириной и высотой. В результате не создается новый ресурс.
    *
    * @param int $id Идентификатор ресурса для обработки
    * @param mixed[] $size_px Размер сгенерированного изображения в формате [ширина, высота]
    * @param string $targetPath Путь к конечному файлу
    *
    */
  public function processCustom($id, $size_px, $targetPath)
  {
      $resource = $this->entityManager->getRepository(Resource::class)->findOneBy([
        'id'=>$id
      ]);
      $size_px = explode('/', $size_px);
      $params = [
        'width'=>$size_px[0],
        'height'=>$size_px[1],
        'source'=>$this->container->getParameter('upload_directory').$resource->getPath(),
        'target'=>$targetPath,
        'mode'=>1
      ];
      $this->_generateImage($params);
  }

  /**
    * Определяет параметры генерации изображения по пресету и создания нового ресурса.
    *
    * @param Resource $resource Идентификатор ресурса для обработки
    * @param int $presetId Размер сгенерированного изображения в формате [ширина, высота]
    * @param mixed $createdOn Дата создания ресурса
    *
    */
  private function _savePreset($resource, $presetId, $createdOn = NULL)
  {
    $extension = $resource->getExtension();
    foreach($this->container->getParameter('presets') as $p){
      if($p['id'] == $presetId){
        $preset = $p;
      }
    }
    $processorDirectory = $this->container->getParameter('upload_directory').'/imgproc/';
    $targetPath = $processorDirectory.$resource->getId().'_'.$preset['name'].'.'.'jpeg';
    $this->_generateImage([
      'width'=>$preset['width'],
      'height'=>$preset['height'],
      'source'=>$this->container->getParameter('upload_directory').$resource->getPath(),
      'target'=>$targetPath,
      'mode'=>1
    ]);

    $parentEntityId = $resource->getItem()?$resource->getItem()->getId():$resource->getGarbageNode()->getId();
    $filename = $this->resourceService->getUniqueIdentifier(file_get_contents($targetPath), $parentEntityId,filesize($targetPath)).'.'.$extension;

    $resourceParameters = [
      'item_id' => $parentEntityId,
      'extension' => $extension,
      'path' => $targetPath,
      'username' => $resource->getUsername(),
      'filesize' => filesize($targetPath),
      'preset' => $preset['id'],
      'chunkPath' => $resource->getChunkPath(),
      'filename' => $filename,
      'src_filename' => $resource->getSrcFilename(),
      'gid' => $resource->getId(),
      'autogenerated'=>true,
      'type'=>4,
      'created_on'=>$createdOn
    ];

    $this->resourceService->processCompletedUpload($resourceParameters);
    $this->fileSystem->remove($targetPath);
  }


  /**
    * Создает изображение на основе существующего файла и входных параметров с помощью ImageMagick
    *
    * @param mixed[] $params Параметры генерации. Включают в себя путь к источнику, конечному файлу, размеру и режиму генерации
    *
    */
  private function _generateImage($params){
    $imageProcessor = new Imagine();
    $size = new Box($params['width'],$params['height']);
    $mode = $params['mode']==1?ImageInterface::THUMBNAIL_OUTBOUND:ImageInterface::THUMBNAIL_INSET;
    $processorDirectory = $this->container->getParameter('upload_directory').'/imgproc/';
    if(!$this->fileSystem->exists($processorDirectory)){$this->fileSystem->mkDir($processorDirectory);}
    if(!$this->fileSystem->exists(dirname($params['target']))){$this->fileSystem->mkDir(dirname($params['target']));}
    $imageProcessor->open($params['source'])
    ->thumbnail($size, $mode)
    ->save($params['target']);
    $imageProcessor = null;
  }

}
